# -*- coding: utf-8 -*-
"""
systemOfLinearEqn.ipynb

Author: Nishant Yadav
ID : 19CY20025
Created on: 31/08/2022

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oX0SNbHo0qyNRF87aCd9KNAOtyb6y3ud
"""

# System of linear equations can be solved using multiple methods

"""
Conditions for getting a unique solution:

    System needs the input matrix to be square, i.e Number of variables = Number of equations
    Coefficient Matrix needs to be a full-rank, i.e., all rows (or, equivalently, columns) must be linearly independent
"""

# Storing the Coefficient Matrix and Right hand side in NumPy array
import numpy as np

# A is coefficinet matrix
A = np.array([[4, -2, 1], 
              [1, 1, 1], 
              [16, 4, 1]])

# b is the right hand side column vector 
b = np.array([2, -1, 4])

import numpy as np


# write rows in reduced row echelon (rref) form
def invert_matrix(M):
    # store dimension
    n = M.shape[0]

    # A must be square with non-zero determinant
    # assert np.linalg.det(M) != 0

    # identity matrix with same shape as A
    I = np.identity(n=n)

    # form the augmented matrix by concatenating A and I
    M = np.concatenate((M, I), axis=1)

    # move all zeros to buttom of matrix
    M = np.concatenate((M[np.any(M != 0, axis=1)], M[np.all(M == 0, axis=1)]), axis=0)

    # iterate over matrix rows
    for i in range(0, n):

        # initialize row-swap iterator
        j = 1

        # select pivot value
        pivot = M[i][i]

        # find next non-zero leading coefficient
        while pivot == 0 and i + j < n:
            # perform row swap operation
            M[[i, i + j]] = M[[i + j, i]]

            # incrememnt row-swap iterator
            j += 1

            # get new pivot
            pivot = M[i][i]

        # if pivot is zero, remaining rows are all zeros
        if pivot == 0:
            # return inverse matrix
            return M[:, n:]

        # extract row
        row = M[i]

        # get 1 along the diagonal
        M[i] = row / pivot

        # iterate over all rows except pivot to get augmented matrix into reduced row echelon form
        for j in [k for k in range(0, n) if k != i]:
            # subtract current row from remaining rows
            M[j] = M[j] - M[i] * M[j][i]

    # return inverse matrix
    return M[:, n:]

A_inv = invert_matrix(A)
print("Inverse of A: ", A_inv)

# Multiplying both side of Ax = b by A_inv, makes it x = (A_inv)dot(b)

x = np.dot(A_inv, b)
print("Solution of the system of linear equation is:", x)

# Checking if Ax == b

# Comparing all elements of np.dot(A, x) and b
if np.dot(A, x).all() == b.all():
    print("Solution is correct")
else:
    print("You need to look for a mistake up there")